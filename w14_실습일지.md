# SSWU_20190224_CSM 구세원 

컴퓨터 시스템 관리 14주차 실습일지입니다.

### *실습과제 결과*

server-b의 IP 주소 확인

![image](https://user-images.githubusercontent.com/65717358/120226750-c1ecf100-c282-11eb-887c-aff1bd53e850.png)


server-b의 IP로 접속하면 워드프레서로 만든 웹사이트 확인

![image](https://user-images.githubusercontent.com/65717358/120226774-cfa27680-c282-11eb-9622-a9314a9ead76.png)


 
## 1. 새로 배운 내용

### 1.1 Ubuntu package search
- 웹서버를 동작시키기 위한 필요한 요소들을 "LAMP"라고 칭함. 
- Linux, Apache HTTP Server, MySQL, PHP
 1) Apache HTTP Server : HTTP를 따르는 웹 서버
 2) MySQL : 관계형 데이터베이스 관리 시스템으로 이 또한 서버 형태로 운영됨.
 3) PHP : 동적 웹 페이지를 만들기 위해 설계된 프로그래밍 언어 


### 1.2 방화벽 firewall
  1) 방화벽
    - 미리 수립한 보안 정책에 따라 들어오고 나가는 네트워크를 모니터링하고 관리하는 **네트워크 보안 시스템**
    - 신뢰할 수 있는 '내부' 내트워크 ///(구분 장벽 구성)/// 신뢰활 수 없는 '외부' 네트워크
    - 일상에서 방화벽은 건물 내부에서 화재가 발생했을 때 불이 다른 곳으로 번지지 않도록 막는 장벽 역할을 한다. 
      네트워크 상에서의 방화벽 역시 네트워크에서 혹시 모를 보안 문제가 내부에서 퍼지지 않도록 외부와 내부의 경계에서 경비하고 관리하는 역할을 한다. 
  
  2) 정책 기반 방화벽 
    - 정책을 수립하지 않는 방화벽은 외부의 요청을 모두 허용하거나 모두 거부한다. 외부에서의 요청을 모두 거부하게 되면 안전은 보장되지만 내부의 컴퓨터, 서버들이 외부의 인터넷에 연결할 수 없다는 단점이 있다. 
    - 위와 같은 단점을 보완하기 위해 정책을 수립하고 그 정책에 따라 외부의 요청을 수용하는 방화벽을 동작시킨다. 이 때 특정 서버에서 접근하는 경우는 모두 로그를 남겨 이를 분석하고 체크하는 방식으로 보안을 강화한다. 
  
  3) 구축 방법에 따른 방화벽 분류
    - SW 방화벽 // 속도는 상대적으로 느리지만 쉽게 제어할 수 있다는 장점이 있다. 
    - HW 방화벽 // 속도와 성능은 좋지만 그 만큼 가격도 상당하다는 아쉬움이 있다.
    - NPU 기반 방화벽 : SW + HW 방화벽 
  
  4) 방화벽 역사
    - 1세대 방화벽 : 패킷 필터 
      - **Packet 단위 검사** = 패킷은 데이터 정보와 헤더 정보를 구성되어 있는데 이 헤더 정보에 담긴 출발지 IP, PORT번호, 도착지 IP를 확인해 어디서 온 패킷인지(출발지 IP), 어디로 갈 패킷인지 (PORT 번호)를 확인하여 정책에 따라 허용이나 거부하는 방식 
      - 패킷이 증가하면 하나하나 검사해야 하므로 load가 많아져 대기시간이 길어진다는 단점이 있다.    
    - 2세대 방화벽 : 스테이트풀  인스펙션 
      - 패킷 필터의 단점을 보완하여 '세션 단위'로 검사 
    - 3세대 방화벽 : 애플리케이션 방화벽   
      - 응용프로그램에 끼칠 영향을 분석하는 방화벽 
      
  5) 방화벽 역할 및 기능 // 사설 ip로 네트워크가 구성된 경우
    
  6) [실습] 방화벽 컴퓨터 구현하기 - 네트워크 구성도 

- 웹 서버의 역할, 웹 서버의 역할이 무엇인지 정확히 이해하는 것이 우선. 
- 클라이언트가 웹 브라우저를 통해 요청하면 웹서버, PHP, DB SERVER 순으로 요청을 읽고 각자가 할 수 있는 역할을 해냄. 우선 웹서버가 PHP에 클라이언트의 요청을 전송하고 PHP는 해당하는 정보를 불러오기 위해 DB에 요청한다. DB가 정보를 PHP에 전송하면 PHP는 그 정보를 보여주는 화면, WEB PAGE를 생성하여 웹 서버에 제공한다. 웹 서버는 만들어진 웹 페이지를 웹 서버를 통해 클라이언트에게 응답해준다. 
- 웹 서버는 80번 포트를 Listener로 사용하여 항상 클라이언트의 요청에 귀를 열고 있다. 그래서 클라이언트가 요청을 하면 바로 접수할 수 있다. 
- 위에서의 과정에서 OS, WEB, DB, PHP의 조합으로 주로 쓰이는 것 중 하나가 바로 "LAMP"이다. 
- 많이 사용하는 Web server로는 NGINX와 APACHE가 있다. NGINX는 아파치의 부동의 1위 자리를 빼앗으며 새로운 강자로 떠오른 웹 서버 프로그램이다. APACHE보다는 난이도가 어렵지만 아파치와 달리 비동기식(이벤트방식)이므로 80포트에서 계속해서 연락이 들어오길 기다리며 접속해 있는 것이 아니라 연락이 왔을 때만 접속해서 처리하고 만다. 


## 2. 발생한 문제/고민한 점 및 해결방법

- [3. 참고내용 -1)] 웹 서버에 대한 자세한 설명을 위해 참고하기 좋은 MDN 페이지를 발견했다. 번역투로 쓰여있어 직관적인 이해는 조금 힘들지만 배운 개념을 다듬는데에는 괜찮았다. 
- [3. 참고내용 -2)] MDN의 내용에 덧붙여 더 이해하기 쉽게 설명되어 있는 페이지를 찾았다. 하드웨어 측면에서, 소프트에어 측면에서 각각 웹서버를 어떻게 설명할 수 있는지도 나와있어 웹 서버 개념이 더 확실해졌다.  

## 3. 참고 내용

1) https://developer.mozilla.org/ko/docs/Learn/Common_questions/What_is_a_web_server 
2) https://velog.io/@muchogusto/%EC%9B%B9%EC%84%9C%EB%B2%84%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80

## 4. 회고    
    
### 4.1 좋았던 점 +
	
- 구글링을 하다보면 비슷한 템플릿은 아니고 각자 자신이 만든 페이지를 이용하는 경우를 많이 봤었다. 외주를 맡기거나 웹빌더 사이트에서 만든 것 같진 않지만 굉장히 체계적이고 잘 구성되어 있는 웹사이트를 볼 때마다 신기했었는데, 이번 수업을 통해 그 사이트들이 어떻게 만들어졌는지 알게 되어서 매우 뿌듯했다. 나 역시 직접 나만의 페이지를 만들어 그곳에 개발 기록을 남겨보고 싶다는 생각도 했다. 

### 4.2 아쉬웠던 점 -
	
- 실습은 교수님의 설명을 따라가다보니 어렵지 않았지만 개념 부분에서 두루뭉실하게 넘어가게 된 부분들이 있어 직접 찾아보며 공부해보았다. 

### 4.3 새로 깨달은 점 !

- 내가 구글링을 해서 웹 사이트 하나를 여는 데까지 생각보다 많은 프로그램들이 동원되고 있다는 것을 다시 한번 깨달았다. 반대로 생각해보면 개발자가 실제로 웹 사이트를  만들고 배포를 할 때 프론트엔드만 신경쓸 것이 아니라 백엔드의 웹서버, DB까지 모두 챙겨야 한다는 의미가 되어 마냥 쉬운 것만은 아님을 배울 수 있었다. 
